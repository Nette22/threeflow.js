// Generated by CoffeeScript 1.6.3
(function() {
  var GlassMaterial, RenderJob, ScExporter, SunflowRenderer, THREE,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  THREE = window.THREE || {};

  THREE.SunflowRenderer = SunflowRenderer = (function() {
    function SunflowRenderer(options) {
      this.onRenderComplete = __bind(this.onRenderComplete, this);
      this.onRenderProgress = __bind(this.onRenderProgress, this);
      this.onRenderStart = __bind(this.onRenderStart, this);
      this.onConnected = __bind(this.onConnected, this);
      options = options || {};
      this.port = options.port || 3000;
      this.host = options.host || "http://localhost";
      this.connected = false;
      this.rendering = false;
    }

    SunflowRenderer.prototype.connect = function() {
      if (this.connected) {
        return;
      }
      this.socket = io.connect(this.host);
      this.socket.on('connected', this.onConnected);
      this.socket.on('renderstart', this.onRenderStart);
      this.socket.on('renderprogress', this.onRenderProgress);
      this.socket.on('rendercomplete', this.onRenderComplete);
      return null;
    };

    SunflowRenderer.prototype.render = function(scene, camera, width, height) {
      var scContents;
      if (!this.connected) {
        throw new Error("[SunflowRenderer] Call connect() before rendering.");
      } else if (!this.rendering) {
        console.log("RENDER");
        scContents = ScExporter["export"](scene, camera, width, height);
        console.log(scContents);
        this.socket.emit("render", {
          scFile: scContents
        });
      } else {
        console.log("QUEUE?");
      }
      return null;
    };

    SunflowRenderer.prototype.onConnected = function(data) {
      console.log("Sunflow conected.");
      this.connected = true;
      return null;
    };

    SunflowRenderer.prototype.onRenderStart = function(data) {
      console.log("onRenderStart");
      return null;
    };

    SunflowRenderer.prototype.onRenderProgress = function(data) {
      console.log("onRenderProgress");
      return null;
    };

    SunflowRenderer.prototype.onRenderComplete = function(data) {
      console.log("onRenderComplete");
      return null;
    };

    return SunflowRenderer;

  })();

  ScExporter = (function() {
    function ScExporter() {}

    ScExporter["export"] = function(scene, camera, width, height) {
      var index, scContents;
      index = ScExporter.buildIndex(scene);
      scContents = "\n% Three.js generated Sunflow scene file.\n";
      scContents += 'image {\n';
      scContents += '  resolution ' + width + ' ' + height + '\n';
      scContents += '  aa 0 1\n';
      scContents += '  filter triangle\n';
      scContents += '}\n\n';
      scContents += 'light {\n';
      scContents += '  type sunsky\n';
      scContents += '  up 0 1 0\n';
      scContents += '  east 0 0 1\n';
      scContents += '  sundir 1 1 1\n';
      scContents += '  turbidity 4\n';
      scContents += '  samples 64\n';
      scContents += '}\n\n';
      scContents += this.exportCamera(camera);
      scContents += this.exportShaders(index);
      scContents += this.exportObjects(index);
      ScExporter.disposeIndex(index);
      return scContents;
    };

    ScExporter.buildIndex = function(scene) {
      var geometryMap, index, map, materialMap, meshMap, traverse;
      materialMap = {};
      meshMap = {};
      geometryMap = {};
      map = function(object3d) {
        if (object3d instanceof THREE.Mesh) {
          meshMap[object3d.uuid] = object3d;
          geometryMap[object3d.geometry.uuid] = object3d.geometry;
          return materialMap[object3d.material.uuid] = object3d.material;
        } else if (object3d instanceof THREE.Camera) {
          return console.log("camera", object3d);
        }
      };
      traverse = function(object3d) {
        var child, _i, _len, _ref, _results;
        if (object3d.children.length) {
          _ref = object3d.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            map(child);
            _results.push(traverse(child));
          }
          return _results;
        }
      };
      traverse(scene);
      index = {
        materials: materialMap,
        geometries: geometryMap,
        meshes: meshMap
      };
      return index;
    };

    ScExporter.disposeIndex = function(index) {
      var key;
      for (key in index.materials) {
        index.materials[key] = null;
        delete index.materials[key];
      }
      for (key in index.geometries) {
        index.geometries[key] = null;
        delete index.geometries[key];
      }
      for (key in index.meshes) {
        index.meshes[key] = null;
        delete index.meshes[key];
      }
      return null;
    };

    ScExporter.exportCamera = function(camera) {
      var scContents;
      scContents = '';
      if (camera instanceof THREE.PerspectiveCamera) {
        scContents += 'camera {\n';
        scContents += '  type pinhole\n';
        scContents += '  eye ' + ScExporter.exportVector(camera.position) + '\n';
        scContents += '  target ' + ScExporter.exportVector(camera.rotation) + '\n';
        scContents += '  up ' + ScExporter.exportVector(camera.up) + "\n";
        scContents += '  fov ' + (camera.fov + 50) + '\n';
        scContents += '  aspect ' + camera.aspect + '\n';
        scContents += '}\n\n';
      } else {
        console.log("Unsupported camera type");
      }
      return scContents;
    };

    ScExporter.exportShaders = function(index) {
      var material, scContents;
      scContents = '';
      for (material in index.materials) {
        material = index.materials[material];
        scContents += 'shader {\n';
        scContents += '  name ' + material.uuid + '\n';
        scContents += '  type diffuse\n';
        scContents += '  diff ' + ScExporter.exportColor(material.color) + '\n';
        scContents += '}\n\n';
      }
      return scContents;
    };

    ScExporter.exportObjects = function(index) {
      var mesh, scContents;
      scContents = '';
      for (mesh in index.meshes) {
        mesh = index.meshes[mesh];
        if (mesh.geometry instanceof THREE.SphereGeometry) {
          scContents += 'object {\n';
          scContents += '  shader ' + mesh.material.uuid + '\n';
          scContents += '  type sphere\n';
          scContents += '  name ' + mesh.uuid + '\n';
          scContents += '  c ' + ScExporter.exportVector(mesh.position) + '\n';
          scContents += '  r ' + mesh.geometry.radius + '\n';
          scContents += '}\n\n';
        }
      }
      return scContents;
    };

    ScExporter.exportVector = function(vector) {
      return vector.x + " " + vector.y + " " + vector.z;
    };

    ScExporter.exportColor = function(color) {
      return '{ "sRGB nonlinear" ' + color.r + ' ' + color.g + ' ' + color.b + ' }';
    };

    return ScExporter;

  })();

  THREE.GlassMaterial = GlassMaterial = (function(_super) {
    __extends(GlassMaterial, _super);

    function GlassMaterial() {
      GlassMaterial.__super__.constructor.call(this);
    }

    GlassMaterial.prototype.test = function() {
      return null;
    };

    return GlassMaterial;

  })(THREE.Material);

  RenderJob = (function() {
    function RenderJob(scExport) {}

    RenderJob.prototype.test = function() {
      return null;
    };

    return RenderJob;

  })();

}).call(this);
