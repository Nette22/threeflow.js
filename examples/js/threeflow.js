// Generated by CoffeeScript 1.6.3
(function() {
  var BlockExporter, DatGUI, Exporter, GlassMaterial, ImageSettingsExporter, ScExporter, SunflowRenderer, THREE,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  THREE = window.THREE || {};

  THREE.SunflowRenderer = SunflowRenderer = (function() {
    SunflowRenderer.IMAGE_FILTERS = ['box', 'triangle', 'gaussian', 'mitchell', 'catmull-rom', 'blackman-harris', 'sinc', 'lanczos', 'ospline'];

    SunflowRenderer.GI_TYPES = ['igi', 'irr-cache', 'path', 'ambocc', 'fake'];

    SunflowRenderer.IRR_CACHE_MAP_TYPES = ['grid', 'path'];

    SunflowRenderer.BUCKET_ORDERS = ['hilbert', 'spiral', 'column', 'row', 'diagonal', 'random'];

    function SunflowRenderer(options) {
      this.onRenderComplete = __bind(this.onRenderComplete, this);
      this.onRenderProgress = __bind(this.onRenderProgress, this);
      this.onRenderStart = __bind(this.onRenderStart, this);
      this.onConnected = __bind(this.onConnected, this);
      options = options || {};
      this.port = options.port || 3000;
      this.host = options.host || "http://localhost";
      this.exporter = new Exporter();
      this.connected = false;
      this.rendering = false;
      this.imageSettings = {
        enabled: true,
        resolutionX: 800,
        resolutionY: 600,
        antialiasMin: 0,
        antialiasMax: 2,
        samples: 4,
        contrast: 0.1,
        filter: THREE.SunflowRenderer.IMAGE_FILTERS[0],
        jitter: false,
        bucketSize: 48,
        bucketOrder: THREE.SunflowRenderer.BUCKET_ORDERS[0],
        bucketOrderReverse: false
      };
      this.traceDepthsSettings = {
        enabled: false,
        diffusion: 1,
        reflection: 4,
        refraction: 4
      };
      this.causticsSettings = {
        enabled: false,
        photons: 10000,
        kdEstimate: 100,
        kdRadius: 0.5
      };
      this.giIgiSettings = {
        samples: 64,
        sets: 1,
        bias: 0.01,
        biasSamples: 0
      };
      this.giIrrCacheSettings = {
        samples: 512,
        tolerance: 0.01,
        spacingMin: 0.05,
        spacingMax: 5.0,
        globalEnabled: false,
        globalPhotons: 10000,
        globalMap: THREE.SunflowRenderer.IRR_CACHE_MAP_TYPES[0],
        globalEstimate: 100,
        globalRadius: 0.75
      };
      this.giPathSettings = {
        samples: 32
      };
      this.giAmbOccSettings = {
        samples: 32,
        bright: 0xffffff,
        dark: 0x000000,
        maxDistance: 3.0
      };
      this.giFakeSettings = {
        up: new THREE.Vector3(),
        sky: 0x000000,
        ground: 0xffffff
      };
      this.gui = new DatGUI(this);
    }

    SunflowRenderer.prototype.connect = function() {
      if (this.connected) {
        return;
      }
      this.socket = io.connect(this.host);
      this.socket.on('connected', this.onConnected);
      this.socket.on('renderstart', this.onRenderStart);
      this.socket.on('renderprogress', this.onRenderProgress);
      this.socket.on('rendercomplete', this.onRenderComplete);
      return null;
    };

    SunflowRenderer.prototype.render = function(scene, camera, width, height) {
      var scContents;
      if (!this.connected) {
        throw new Error("[SunflowRenderer] Call connect() before rendering.");
      } else if (!this.rendering) {
        console.log("RENDER");
        scContents = ScExporter["export"](scene, camera, width, height);
        console.log(scContents);
        this.socket.emit("render", {
          scFile: scContents
        });
      } else {
        console.log("QUEUE?");
      }
      return null;
    };

    SunflowRenderer.prototype.onConnected = function(data) {
      console.log("Sunflow conected.");
      this.connected = true;
      return null;
    };

    SunflowRenderer.prototype.onRenderStart = function(data) {
      console.log("onRenderStart");
      return null;
    };

    SunflowRenderer.prototype.onRenderProgress = function(data) {
      console.log("onRenderProgress");
      return null;
    };

    SunflowRenderer.prototype.onRenderComplete = function(data) {
      console.log("onRenderComplete");
      return null;
    };

    return SunflowRenderer;

  })();

  BlockExporter = (function() {
    function BlockExporter() {}

    BlockExporter.prototype.settings = function() {
      throw new Error('BlockExporter subclasses must override this method.');
    };

    BlockExporter.prototype.addToIndex = function(object3d) {
      throw new Error('BlockExporter subclasses must override this method.');
    };

    BlockExporter.prototype.doTraverse = function(object3d) {
      throw new Error('BlockExporter subclasses must override this method.');
    };

    BlockExporter.prototype["export"] = function() {
      throw new Error('BlockExporter subclasses must override this method.');
    };

    return BlockExporter;

  })();

  Exporter = (function() {
    function Exporter() {
      console.log("New Exporter");
      this.exporterSettings = {
        convertPrimitives: false
      };
      this.blockExporters = [];
      this.addBlockExporter(new ImageSettingsExporter());
    }

    Exporter.prototype.addBlockExporter = function(exporter) {
      if (!exporter instanceof BlockExporter) {
        throw new Error('Extend BlockExporter');
      } else {
        return this.blockExporters.push(exporter);
      }
    };

    Exporter.prototype.indexScene = function(object3d) {
      var blockExporter, child, doTraverse, _i, _j, _len, _len1, _ref, _ref1;
      if (object3d.children.length) {
        _ref = object3d.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          doTraverse = true;
          _ref1 = this.blockExporters;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            blockExporter = _ref1[_j];
            blockExporter.index(child);
            doTraverse = doTraverse && blockExporter.doTraverse(child);
          }
          if (doTraverse) {
            this.indexScene(child);
          }
        }
      }
      return null;
    };

    Exporter.prototype.exportSc = function() {
      var blockExporter, result, _i, _len;
      result = '';
      for (_i = 0, _len = blockExporter.length; _i < _len; _i++) {
        blockExporter = blockExporter[_i];
        result += blockExporter["export"]();
      }
      return result;
    };

    return Exporter;

  })();

  ImageSettingsExporter = (function(_super) {
    __extends(ImageSettingsExporter, _super);

    ImageSettingsExporter.FILTERS = ['box', 'triangle', 'gaussian', 'mitchell', 'catmull-rom', 'blackman-harris', 'sinc', 'lanczos', 'ospline'];

    ImageSettingsExporter.BUCKET_ORDERS = ['hilbert', 'spiral', 'column', 'row', 'diagonal', 'random'];

    function ImageSettingsExporter() {
      ImageSettingsExporter.__super__.constructor.call(this);
      this.imageSettings = {
        enabled: true,
        resolutionX: 800,
        resolutionY: 600,
        antialiasMin: 0,
        antialiasMax: 2,
        samples: 4,
        contrast: 0.1,
        filter: ImageSettingsExporter.FILTERS[0],
        jitter: false,
        bucketSize: 48,
        bucketOrder: THREE.SunflowRenderer.BUCKET_ORDERS[0],
        bucketOrderReverse: false
      };
    }

    ImageSettingsExporter.prototype.handles = function(object3d) {
      return null;
    };

    ImageSettingsExporter.prototype.settings = function() {
      return this.imageSettings;
    };

    ImageSettingsExporter.prototype["export"] = function(object3d) {
      var result;
      result = '';
      if (enabled) {
        result;
      }
      return result;
    };

    return ImageSettingsExporter;

  })(BlockExporter);

  ScExporter = (function() {
    function ScExporter() {}

    ScExporter["export"] = function(scene, camera, width, height) {
      var index, scContents;
      index = ScExporter.buildIndex(scene);
      scContents = "\n% Three.js generated Sunflow scene file.\n";
      scContents += 'image {\n';
      scContents += '  resolution ' + width + ' ' + height + '\n';
      scContents += '  aa 0 1\n';
      scContents += '  filter triangle\n';
      scContents += '}\n\n';
      scContents += 'light {\n';
      scContents += '  type sunsky\n';
      scContents += '  up 0 1 0\n';
      scContents += '  east 0 0 1\n';
      scContents += '  sundir 1 1 1\n';
      scContents += '  turbidity 4\n';
      scContents += '  samples 64\n';
      scContents += '}\n\n';
      scContents += this.exportCamera(camera);
      scContents += this.exportShaders(index);
      scContents += this.exportObjects(index);
      ScExporter.disposeIndex(index);
      return scContents;
    };

    ScExporter.buildIndex = function(scene) {
      var geometryMap, index, map, materialMap, meshMap, traverse;
      materialMap = {};
      meshMap = {};
      geometryMap = {};
      map = function(object3d) {
        if (object3d instanceof THREE.Mesh) {
          meshMap[object3d.uuid] = object3d;
          geometryMap[object3d.geometry.uuid] = object3d.geometry;
          return materialMap[object3d.material.uuid] = object3d.material;
        } else if (object3d instanceof THREE.Camera) {
          return console.log("camera", object3d);
        }
      };
      traverse = function(object3d) {
        var child, _i, _len, _ref, _results;
        if (object3d.children.length) {
          _ref = object3d.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            map(child);
            _results.push(traverse(child));
          }
          return _results;
        }
      };
      traverse(scene);
      index = {
        materials: materialMap,
        geometries: geometryMap,
        meshes: meshMap
      };
      return index;
    };

    ScExporter.disposeIndex = function(index) {
      var key;
      for (key in index.materials) {
        index.materials[key] = null;
        delete index.materials[key];
      }
      for (key in index.geometries) {
        index.geometries[key] = null;
        delete index.geometries[key];
      }
      for (key in index.meshes) {
        index.meshes[key] = null;
        delete index.meshes[key];
      }
      return null;
    };

    ScExporter.exportCamera = function(camera) {
      var scContents;
      scContents = '';
      if (camera instanceof THREE.PerspectiveCamera) {
        scContents += 'camera {\n';
        scContents += '  type pinhole\n';
        scContents += '  eye ' + ScExporter.exportVector(camera.position) + '\n';
        scContents += '  target ' + ScExporter.exportVector(camera.rotation) + '\n';
        scContents += '  up ' + ScExporter.exportVector(camera.up) + "\n";
        scContents += '  fov ' + 59. + '\n';
        scContents += '  aspect ' + camera.aspect + '\n';
        scContents += '}\n\n';
      } else {
        console.log("Unsupported camera type");
      }
      return scContents;
    };

    ScExporter.exportShaders = function(index) {
      var material, scContents;
      scContents = '';
      for (material in index.materials) {
        material = index.materials[material];
        scContents += 'shader {\n';
        scContents += '  name ' + material.uuid + '\n';
        scContents += '  type diffuse\n';
        scContents += '  diff ' + ScExporter.exportColor(material.color) + '\n';
        scContents += '}\n\n';
      }
      return scContents;
    };

    ScExporter.exportObjects = function(index) {
      var face, geometry, mesh, scContents, vertex, _i, _j, _len, _len1, _ref, _ref1;
      scContents = '';
      for (geometry in index.geometries) {
        geometry = index.geometries[geometry];
        scContents += 'object {\n';
        scContents += '  noinstance\n';
        scContents += '  type generic-mesh\n';
        scContents += '  name ' + geometry.uuid + '\n';
        scContents += '  points ' + geometry.vertices.length + '\n';
        _ref = geometry.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vertex = _ref[_i];
          scContents += '    ' + ScExporter.exportVector(vertex) + '\n';
        }
        scContents += '  triangles ' + geometry.faces.length + '\n';
        _ref1 = geometry.faces;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          face = _ref1[_j];
          scContents += '    ' + ScExporter.exportFace(face) + '\n';
        }
        scContents += '  normals none\n';
        scContents += '  uvs none\n';
        scContents += '}\n\n';
      }
      for (mesh in index.meshes) {
        mesh = index.meshes[mesh];
        /*
        if mesh.geometry instanceof THREE.SphereGeometry
          scContents += 'object {\n'
          scContents += '  shader ' + mesh.material.uuid + '\n'
          scContents += '  type sphere\n'
          scContents += '  name ' + mesh.uuid + '\n'
          scContents += '  c ' + ScExporter.exportVector(mesh.position) + '\n'
          scContents += '  r ' + mesh.geometry.radius + '\n'
          scContents += '}\n\n'
        else
        */

        scContents += 'instance {\n';
        scContents += '  name ' + mesh.uuid + '\n';
        scContents += '  geometry ' + mesh.geometry.uuid + '\n';
        scContents += ScExporter.exportTransform(mesh);
        scContents += '  shader ' + mesh.material.uuid + '\n';
        scContents += '}\n\n';
      }
      return scContents;
    };

    ScExporter.exportVector = function(vector) {
      return vector.x + " " + vector.y + " " + vector.z;
    };

    ScExporter.exportFace = function(face) {
      return face.a + " " + face.b + " " + face.c;
    };

    ScExporter.exportTransform = function(object3d) {
      var element, scContents, _i, _len, _ref;
      scContents = '';
      scContents += '  transform col';
      _ref = object3d.matrixWorld.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        scContents += ' ' + element;
      }
      scContents += '\n';
      return scContents;
    };

    ScExporter.exportColor = function(color) {
      return '{ "sRGB nonlinear" ' + color.r + ' ' + color.g + ' ' + color.b + ' }';
    };

    return ScExporter;

  })();

  THREE.GlassMaterial = GlassMaterial = (function(_super) {
    __extends(GlassMaterial, _super);

    function GlassMaterial() {
      GlassMaterial.__super__.constructor.call(this);
    }

    GlassMaterial.prototype.test = function() {
      return null;
    };

    return GlassMaterial;

  })(THREE.Material);

  DatGUI = (function() {
    function DatGUI(renderer) {
      this.renderer = renderer;
      this.create();
    }

    DatGUI.prototype.create = function() {
      this.gui = new dat.GUI();
      this.imageFolder = this.gui.addFolder("Image Settings");
      this.imageFolder.add(this.renderer.imageSettings, 'resolutionX');
      this.imageFolder.add(this.renderer.imageSettings, 'resolutionY');
      this.imageFolder.add(this.renderer.imageSettings, 'antialiasMin');
      this.imageFolder.add(this.renderer.imageSettings, 'antialiasMax');
      this.imageFolder.add(this.renderer.imageSettings, 'samples');
      this.imageFolder.add(this.renderer.imageSettings, 'contrast');
      this.imageFolder.add(this.renderer.imageSettings, 'filter', THREE.SunflowRenderer.IMAGE_FILTERS);
      this.imageFolder.add(this.renderer.imageSettings, 'jitter');
      this.traceDepthsFolder = this.gui.addFolder("Trace Depths");
      this.traceDepthsFolder.add(this.renderer.traceDepthsSettings, 'enabled');
      this.traceDepthsFolder.add(this.renderer.traceDepthsSettings, 'diffusion');
      this.traceDepthsFolder.add(this.renderer.traceDepthsSettings, 'reflection');
      this.traceDepthsFolder.add(this.renderer.traceDepthsSettings, 'refraction');
      this.causticsFolder = this.gui.addFolder("Caustics");
      this.causticsFolder.add(this.renderer.causticsSettings, 'enabled');
      this.causticsFolder.add(this.renderer.causticsSettings, 'photons');
      this.causticsFolder.add(this.renderer.causticsSettings, 'kdEstimate');
      this.causticsFolder.add(this.renderer.causticsSettings, 'kdRadius');
      return null;
    };

    return DatGUI;

  })();

}).call(this);
